/**
 * Astro Integration for Responsive Privacy
 *
 * Hooks into Astro's build lifecycle to:
 * 1. Read the PRIVACY_LEVEL from environment
 * 2. Log build summary showing what will be hidden
 * 3. Provide the privacy context to components via Vite virtual module
 *
 * Usage in astro.config.mjs:
 *
 *   import { responsivePrivacy } from '@responsive-privacy/astro';
 *   import privacyConfig from './responsive-privacy.config';
 *
 *   export default defineConfig({
 *     integrations: [responsivePrivacy(privacyConfig)],
 *   });
 */

import type { AstroIntegration } from 'astro';
import {
  type ResponsivePrivacyConfig,
  type PrivacyLevel,
  createContext,
  readPrivacyLevel,
  resolveConfig,
} from '@responsive-privacy/core';

const VIRTUAL_MODULE_ID = 'virtual:responsive-privacy';
const RESOLVED_VIRTUAL_MODULE_ID = '\0' + VIRTUAL_MODULE_ID;

export interface ResponsivePrivacyOptions extends ResponsivePrivacyConfig {
  /**
   * Override the privacy level instead of reading from PRIVACY_LEVEL env var.
   * Useful for testing or for passing from a build script.
   */
  level?: PrivacyLevel;

  /**
   * Print build summary to console. Defaults to true.
   */
  verbose?: boolean;
}

export function responsivePrivacy(
  options: ResponsivePrivacyOptions
): AstroIntegration {
  const { level, verbose = true, ...config } = options;
  const currentLevel = level ?? readPrivacyLevel();
  const resolved = resolveConfig(config);
  const ctx = createContext(config, currentLevel);

  const levelDef = resolved.levels.find((l) => l.level === currentLevel);

  return {
    name: 'responsive-privacy',
    hooks: {
      'astro:config:setup': ({ updateConfig, logger }) => {
        if (verbose) {
          logger.info(
            `Privacy Level: ${currentLevel} — ${levelDef?.name ?? 'Unknown'}`
          );
          if (currentLevel < 4) {
            logger.warn(
              `Building with reduced visibility. Some content will be hidden or redacted.`
            );
          }
        }

        // Inject a Vite plugin that provides the virtual module
        updateConfig({
          vite: {
            plugins: [
              {
                name: 'responsive-privacy-virtual',
                resolveId(id: string) {
                  if (id === VIRTUAL_MODULE_ID) {
                    return RESOLVED_VIRTUAL_MODULE_ID;
                  }
                },
                load(id: string) {
                  if (id === RESOLVED_VIRTUAL_MODULE_ID) {
                    return generateVirtualModule(currentLevel, resolved);
                  }
                },
              },
            ],
          },
        });
      },

      'astro:build:start': ({ logger }) => {
        if (verbose && currentLevel < 4) {
          // Log which attribute categories will be affected
          const hiddenAttrs = Object.entries(resolved.attributes)
            .filter(([_, attr]) => attr.threshold > currentLevel)
            .map(([id, attr]) => `${id} (${attr.name})`);

          if (hiddenAttrs.length > 0) {
            logger.info(`Attributes hidden at Level ${currentLevel}:`);
            for (const attr of hiddenAttrs) {
              logger.info(`  ⬛ ${attr}`);
            }
          }
        }
      },
    },
  };
}

/**
 * Generate the virtual module code that components can import.
 */
function generateVirtualModule(
  currentLevel: PrivacyLevel,
  config: Required<ResponsivePrivacyConfig>
): string {
  // Serialize just what templates need — keep it lightweight
  const serializedAttributes = JSON.stringify(
    Object.fromEntries(
      Object.entries(config.attributes).map(([id, attr]) => [
        id,
        { threshold: attr.threshold, redaction: attr.redaction ?? 'omit', redactedValue: attr.redactedValue },
      ])
    )
  );

  const serializedCollections = JSON.stringify(config.collections);

  return `
// Auto-generated by @responsive-privacy/astro
// Privacy Level: ${currentLevel}

export const PRIVACY_LEVEL = ${currentLevel};
export const LEVEL_NAME = ${JSON.stringify(config.levels.find(l => l.level === currentLevel)?.name ?? 'Unknown')};

const _attributes = ${serializedAttributes};
const _collections = ${serializedCollections};

/**
 * Check if a specific attribute ID is visible at the current build level.
 */
export function isVisible(attributeId) {
  const attr = _attributes[attributeId];
  if (!attr) return true;
  return ${currentLevel} >= attr.threshold;
}

/**
 * Check if a specific field in a collection is visible.
 */
export function isFieldVisible(collectionName, fieldName) {
  const collection = _collections[collectionName];
  if (!collection) return true;
  const attributeId = collection.fields[fieldName];
  if (!attributeId) return true;
  return isVisible(attributeId);
}

/**
 * Get the redacted value for an attribute, or undefined if omitted.
 */
export function redactedValueFor(attributeId) {
  const attr = _attributes[attributeId];
  if (!attr) return undefined;
  if (attr.redaction === 'replace') return attr.redactedValue ?? '[Hidden]';
  return undefined;
}
`;
}

// Re-export core types and functions for convenience
export {
  defineConfig,
  resolveConfig,
  createContext,
  readPrivacyLevel,
  transformEntry,
  transformCollection,
  buildSummary,
  isAttributeVisible,
} from '@responsive-privacy/core';

export type {
  ResponsivePrivacyConfig,
  PrivacyLevel,
  PrivacyContext,
  TransformResult,
  AttributeDefinition,
} from '@responsive-privacy/core';
